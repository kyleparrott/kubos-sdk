#!/usr/bin/env python

# Kubos SDK
# Copyright (C) 2016 Kubos Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import json
import os
import sys
import subprocess
import time
import threading

from docker import Client
import docker

from utils import version, container

container_repo = 'kubostech/kubos-sdk'
container_tag = '0.0.2'
yotta_meta_file = '.yotta.json'
module_file_name = 'module.json'

def main():
    argparse.ArgumentParser._check_value = pass_through_check_value
    parser = argparse.ArgumentParser('kubos')
    subparser = parser.add_subparsers(dest='command', help='Available kubos commands')

    build_parser  = subparser.add_parser('build', help='build the project in the current directory')
    flash_parser  = subparser.add_parser('flash', help='launch the built executable')
    init_parser   = subparser.add_parser('init', help='initialize a new kubos project in the current directory')
    link_parser   = subparser.add_parser('link', help='symlink a module to be used into another module')
    target_parser = subparser.add_parser('target', help='set or display the current target hardware platform')
    remove_parser = subparser.add_parser('remove', help='remove a symlinked module')
    update_parser = subparser.add_parser('update', help='pull latest kubos-sdk docker container')
    version_parser = subparser.add_parser('version', help='display version information')

    init_parser.add_argument('proj_name', nargs=1, type=str)
    link_parser.add_argument('path', nargs='?', type=str)
    remove_parser.add_argument('module', nargs='?', type=str)
    target_parser.add_argument('target', nargs='?', type=str)

    build_parser.set_defaults(func=pass_through)
    init_parser.set_defaults(func=pass_through)
    link_parser.set_defaults(func=link)
    target_parser.set_defaults(func=pass_through)
    update_parser.set_defaults(func=update)
    remove_parser.set_defaults(func=remove)
    version_parser.set_defaults(func=print_version)

    args, unknown_args = parser.parse_known_args()
    provided_args = vars(args)

    command = provided_args['command']
    if command == 'init':
        update()
        proj_name = provided_args['proj_name'][0]
        pass_through(command, proj_name)
    elif command == 'target':
        target = provided_args['target']
        if target:
            pass_through(command, target)
        else:
            pass_through(command)
    elif command == 'update':
        update()
    elif command == 'build':
        pass_through(command, *unknown_args)
    elif command == 'flash':
        flash()
    elif command == 'link':
        link(provided_args['path'])
    elif command == 'remove':
        remove(provided_args['module'])
    elif command == 'version':
        print_version()


def update():
    print "Checking for latest KubOS-SDK.."
    cli = container.get_cli()
    status_spinner = start_spinner()
    for line in cli.pull(repository=container_repo, tag=container_tag, stream=True):
       json_data = json.loads(line)
       if 'error' in json_data:
            print json_data['error'].encode('utf8')
       elif 'progress' in json_data:
            sys.stdout.write('\r%s' % json_data['progress'].encode('utf8'))
            time.sleep(0.1)
            sys.stdout.flush()
       elif 'status' in json_data:
            print json_data['status'].encode('utf8')
    print "All up to date!\n"
    stop_spinner(status_spinner)

def print_version():
    print "KubOS-SDK:\t\t%s" % (version.get_kubos_sdk_version())
    print "KubOS-SDK Container:\t%s" % (version.get_container_tag())


def pass_through(*args):
    cwd = os.getcwd()
    cli = container.get_cli()
    python = '/usr/bin/python'
    sdk_script = '/kubos-sdk/kubos-sdk.py'
    arg_list = list(args)
    arg_list.insert(0, python)
    arg_list.insert(1, sdk_script)

    image_name = "%s:%s" % (container_repo, container_tag)
    container_data = cli.create_container(image=image_name, command=arg_list, working_dir=cwd, tty=True)
    container_id = container_data['Id'].encode('utf8')
    if container_data['Warnings']:
        print "Warnings: ", container_data['Warnings']

    bind_dirs = []
    kubos_module_file = get_kubos_module_file()
    if os.path.isfile(kubos_module_file):
        with open(kubos_module_file, 'r') as module_file:
            link_data = json.load(module_file)
        for key in link_data:
            #All linked modules are mounted at /mnt/<module_name>
            mount_path = os.path.join('/', 'mnt', key)
            path = '%s:%s' % (link_data[key], mount_path)
            bind_dirs.append(path)
    cwd_bind = '%s:%s' % (cwd, cwd)
    bind_dirs.append(cwd_bind)

    status_spinner = start_spinner()
    cli.start(container_id, binds=bind_dirs)
    container_output = cli.logs(container=container_id, stream=True)
    for entry in container_output:
        sys.stdout.write(entry)

    cli.stop(container_id)
    cli.remove_container(container_id)

    if sys.platform.startswith('linux'):
        fix_permissions()
    stop_spinner(status_spinner)


def fix_permissions(*args):
    cwd = os.getcwd()
    cli = container.get_cli()
    userstr = "%s:%s" % (os.getuid(), os.getgid())
    arg_list = list()
    arg_list.insert(0, "chown")
    arg_list.insert(1, userstr)
    arg_list.insert(2, cwd)
    arg_list.insert(3, "-R")

    image_name = "%s:%s" % (container_repo, container_tag)
    container_data = cli.create_container(image=image_name, command=arg_list, working_dir=cwd, tty=True)

    container_id = container_data['Id'].encode('utf8')
    if container_data['Warnings']:
        print "Warnings: ", container_data['Warnings']

    cli.start(container_id, binds={
        cwd : {
            'bind': cwd,
            'ro': False
        }
    })
    container_output = cli.logs(container=container_id, stream=True)
    for entry in container_output:
        sys.stdout.write(entry)

    cli.stop(container_id)
    cli.remove_container(container_id)


def flash():
    current_target = get_current_target()
    if current_target:
        project_name = get_project_name()

        if not project_name:
            print >>sys.stderr, 'Error: No module.json file found. Run "kubos build" in the root directory of your project'
            sys.exit(1)

        install_dir = os.path.dirname(os.path.realpath(__file__))
        proj_exe_path =  os.path.join(os.getcwd(), 'build', current_target, 'source', project_name)
        kubos_dir = os.path.join(install_dir, '..', 'kubos') #the base directory that holds the bin/ lib/ and flash/ directories.

        if current_target.startswith('stm32f407'):
            flash_openocd(proj_exe_path, kubos_dir)
        elif current_target.startswith('stm32f405'):
            flash_dfu_util(proj_exe_path, kubos_dir)
        elif current_target.startswith('msp430'):
            flash_mspdebug(proj_exe_path, kubos_dir)

    else:
        print >>sys.stderr, 'Error: No target currently selected. Select a target and build before flashing'


def flash_openocd(proj_exe_path, kubos_dir):
    if sys.platform.startswith('linux'):
        openocd_exe = os.path.join(kubos_dir, 'bin', 'linux', 'openocd')
        lib_path = os.path.join(kubos_dir, 'lib', 'linux')
    elif sys.platform.startswith('darwin'):
        openocd_exe = os.path.join(kubos_dir, 'bin', 'osx', 'openocd')
        lib_path = os.path.join(kubos_dir, 'lib', 'osx')

    check_env_var(lib_path)
    openocd_dir = os.path.join(kubos_dir, 'flash', 'openocd')
    flash_script_path = os.path.join(openocd_dir, 'flash.sh')
    argument = 'stm32f4_flash %s' % proj_exe_path
    try:
        subprocess.check_call(['/bin/bash', flash_script_path, openocd_exe, argument, openocd_dir])
    except subprocess.CalledProcessError:
        pass


def flash_dfu_util(proj_exe_path, kubos_dir):
    if sys.platform.startswith('linux'):
        dfu_util_exe = os.path.join(kubos_dir, 'bin', 'linux', 'dfu-util')
        lib_path = os.path.join(kubos_dir, 'lib', 'linux')
    elif sys.platform.startswith('darwin'):
        dfu_util_exe = os.path.join(kubos_dir, 'bin', 'osx', 'dfu-util')
        lib_path = os.path.join(kubos_dir, 'lib', 'osx')

    check_env_var(lib_path)
    dfu_util_dir = os.path.join(kubos_dir, 'flash', 'dfu_util')
    flash_script_path = os.path.join(dfu_util_dir, 'flash.sh')
    try:
        subprocess.check_call(['/bin/bash', flash_script_path, dfu_util_exe, proj_exe_path])
    except subprocess.CalledProcessError:
        pass

def flash_mspdebug(proj_exe_path, kubos_dir):
    if sys.platform.startswith('linux'):
        mspdebug_exe = os.path.join(kubos_dir, 'bin', 'linux', 'mspdebug')
        lib_path = os.path.join(kubos_dir, 'lib', 'linux')

    elif sys.platform.startswith('darwin'):
        mspdebug_exe = os.path.join(kubos_dir, 'bin', 'osx', 'mspdebug')
        lib_path = os.path.join(kubos_dir, 'lib', 'osx')

    check_env_var(lib_path)
    flash_script_path = os.path.join(kubos_dir, 'flash', 'mspdebug', 'flash.sh')
    argument = 'prog %s' % proj_exe_path
    try:
        subprocess.check_call(['/bin/bash', flash_script_path, mspdebug_exe, argument])
    except subprocess.CalledProcessError:
        pass


def link(module_path):
    if module_path:
        module_path = os.path.abspath(module_path)
    module_path = module_path or os.getcwd()
    module_json = os.path.join(module_path, 'module.json')
    if os.path.isfile(module_json):
        with open(module_json, 'r') as mod_json:
            module_data = json.load(mod_json)
            module_name = module_data['name']
    else:
        print >>sys.stderr, 'Error, unable to link %s does not contain a module.json' % module_path
        sys.exit(1)
    kubos_file_path = get_kubos_module_file()
    if os.path.isfile(kubos_file_path):
        with open(kubos_file_path, 'r') as meta_file:
            link_data = json.load(meta_file)
            link_data[module_name] = module_path
    else:
        link_data = {module_name : module_path}
    with open(kubos_file_path, 'w') as meta_file:
        str_link_data = json.dumps(link_data)
        meta_file.write(str_link_data)
        print 'Successfully Linked %s: %s' % (module_name, module_path)


def remove(module_name):
    kubos_file_path = get_kubos_module_file() 
    if os.path.isfile(kubos_file_path):
        with open(kubos_file_path, 'r') as meta_file:
            link_data = json.load(meta_file)
        if module_name in link_data:
            link_data.pop(module_name)
            with open(kubos_file_path, 'w') as meta_file:
                new_data = json.dumps(link_data)
                meta_file.write(new_data)
                print 'Successfully unlinked %s' % module_name
        else:
            print >>sys.stderr, 'Module %s is not currently linked' % module_name
            sys.exit(1)
    else:
        print >>sys.stderr, 'No modules are currently linked. Nothing to unlink.'
        sys.exit(1)


def get_kubos_module_file():
    home_dir = os.path.expanduser('~')
    kubos_file_path = os.path.join(home_dir, '.kubos-sdk')
    return kubos_file_path


def check_env_var(path):
    ld_lib_path = 'LD_LIBRARY_PATH'
    if not hasattr(os.environ, ld_lib_path):
        os.environ[ld_lib_path] = path
    else:
        os.environ[ld_lib_path] += ':%s' % path


def get_project_name():
    module_file_path = os.path.join(os.getcwd(), module_file_name)
    if os.path.isfile(module_file_path):
         with open(module_file_path, 'r') as module_file:
            data = json.load(module_file)
            name = data['name']
            return name
    else:
        return None


def get_current_target():
    meta_file_path = os.path.join(os.getcwd(), yotta_meta_file)
    if os.path.isfile(meta_file_path):
        with open(meta_file_path, 'r') as meta_file:
            data = json.load(meta_file)
            target_str = str(data['build']['target'])
            return target_str.split(',')[0]
    else:
        return None


# Override the argparse error handler that deals with undefined subcommands
# to allow these commands to be passed through to the container. The container
# handles passing commands to yotta as well as subcommands unknown to yotta.

def pass_through_check_value(self, action, value):
    if action.choices is not None and value not in action.choices:
        pass_through(value)
        sys.exit()


class StatusSpinner(threading._Timer):
    def run(self):
        spinner = self.get_spinner()
        while True:
            sys.stdout.write(spinner.next())
            sys.stdout.flush()
            time.sleep(0.1)
            sys.stdout.write('\b')

    def get_spinner(self):
        while True:
            for symbol in '|/-\\':
                yield symbol


def start_spinner():
    spinner = StatusSpinner(0.1, None)
    spinner.daemon = True
    spinner.start()
    return spinner


def stop_spinner(spinner):
    spinner.cancel()


if __name__ == '__main__':
    main()
